//
// Apache 2.0 License
// Copyright Pawel Krzywdzinski
//

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;

namespace CodeMarkup.WinUI.Generator.Extensions
{
    public partial class ExtensionGenerator
    {
        readonly GeneratorExecutionContext context;
        readonly INamedTypeSymbol mainSymbol;
        readonly AttributeData attachedInterfacesAttribute;
        readonly bool isDependencyObject;

        StringBuilder builder;
        bool isExtensionMethodsGenerated;

        public ExtensionGenerator(GeneratorExecutionContext context, INamedTypeSymbol symbol)
        {
            this.context = context;
            this.attachedInterfacesAttribute = Shared.GetAttachedInterfacesAttributeData(symbol);
            this.mainSymbol = attachedInterfacesAttribute == null ? symbol : attachedInterfacesAttribute.ConstructorArguments[0].Value as INamedTypeSymbol;
            this.isDependencyObject = Shared.IsDependencyObject(mainSymbol);
        }

        public void Build()
        {
            isExtensionMethodsGenerated = false;
            builder = new StringBuilder();
            builder.AppendLine("//");
            builder.AppendLine($"// <auto-generated> {Shared.CoreLibPrefix}.Generator.Extensions");
            builder.AppendLine("//");
            builder.AppendLine();

            builder.AppendLine("#nullable enable");
            builder.AppendLine("#pragma warning disable CS8601");
            builder.AppendLine();
            builder.AppendLine("using System;");
            builder.AppendLine("using Microsoft.UI.Xaml;");
            builder.AppendLine("using Microsoft.UI.Xaml.Controls;");
            builder.AppendLine("using System.Collections.Generic;");
            builder.AppendLine();

            GenerateExtensionNameSpace();

            builder.AppendLine();
            builder.AppendLine("#pragma warning restore CS8601");
            builder.AppendLine("#nullable restore");


            if (isExtensionMethodsGenerated)
            {
                var tail = 
                    (attachedInterfacesAttribute != null ? ".attached" : "") +
                    (mainSymbol.ContainingNamespace.ToDisplayString().StartsWith(Shared.WinUIPrefix) ? "" : ".extension");

                context.AddSource($"{mainSymbol.ContainingNamespace.ToDisplayString()}.{Helpers.GetNormalizedFileName(mainSymbol)}{tail}.g.cs", builder.ToString());
            }
        }

        public  string GetUsingString()
        {
            if (!mainSymbol.ContainingNamespace.ToDisplayString().StartsWith(Shared.WinUIPrefix))
                return $@"using {Shared.CoreLibPrefix};
    ";
            return "";
        }

        void GenerateExtensionNameSpace()
        {
            var className = $"{Helpers.GetNormalizedClassName(mainSymbol)}Extension";

            builder.Append($@"
namespace {(mainSymbol.ContainingNamespace.ToDisplayString().StartsWith(Shared.WinUIPrefix) ? Shared.CoreLibPrefix : mainSymbol.ContainingNamespace.ToDisplayString())}
{{
    using {Shared.CoreLibPrefix}.Internal;
    {GetUsingString()}
    public static partial class {className}
    {{");
            
            if (attachedInterfacesAttribute != null)
                GenerateAttachedPropertiesExtension();
            else
                GenerateClassExtensionBody();

            builder.AppendLine($@"
    }}
}}");
        }

        List<string> dependencyPropertyNames;

        void GenerateClassExtensionBody()
        {
            dependencyPropertyNames = new List<string>();
            var dependencyProperties = mainSymbol
                    .GetMembers()
                    .Where(e => e.IsStatic && e.Name.EndsWith("Property") && e.DeclaredAccessibility == Accessibility.Public).ToList();

            dependencyPropertyNames.Clear();
            foreach (var prop in dependencyProperties)
            {
                var name = prop.Name.Substring(0, prop.Name.Length - "Property".Length);
                dependencyPropertyNames.Add(name);
            }

            var properties = mainSymbol
                .GetMembers()
                .Where(e => e.Kind == SymbolKind.Property && e.DeclaredAccessibility == Accessibility.Public && !e.IsStatic);

            var events = mainSymbol
                .GetMembers()
                .Where(e => e.Kind == SymbolKind.Event && e.DeclaredAccessibility == Accessibility.Public && !e.IsStatic);

            foreach (var prop in properties)
                GenerateExtensionMethod(prop as IPropertySymbol);

            foreach (var @event in events)
                GenerateEventMethod(@event);

            GenerateDependencyPropertyExtensionsFromInterface();
        }

        class PropertyInfo
        {
            public INamedTypeSymbol MainSymbol { get; set; }
            public IPropertySymbol PropertySymbol { get; set; }
            public List<string> DependencyProperties { get; set; }
            public bool IsDependencyObject { get; set; }
            public bool IsDependencyProperty { get; set; }
            public string DependencyPropertyName { get; set; }

            public string propertyName;
            public string accessedWith;
            public string propertyTypeName;
            public string camelCaseName;
            public string symbolTypeName;
            public string valueAssignmentString;

            public void Build()
            {
                symbolTypeName = $"{MainSymbol.ToDisplayString()}";

                propertyName = PropertySymbol.Name.Split(new[] { "." }, StringSplitOptions.None).Last();
                propertyName = propertyName.Equals("class", StringComparison.Ordinal) ? "@class" : propertyName;

                if (DependencyPropertyName == null)
                {
                    if (DependencyProperties != null) IsDependencyProperty = DependencyProperties.Contains(propertyName);
                    accessedWith = PropertySymbol.IsStatic ? $"{MainSymbol.ToDisplayString()}" : "self";
                    DependencyPropertyName = $"{MainSymbol.ToDisplayString()}.{propertyName}Property";
                }
                else
                    IsDependencyObject = true;
                
                propertyTypeName = PropertySymbol.Type.ToDisplayString();
                camelCaseName = Helpers.CamelCase(propertyName);

                valueAssignmentString = IsDependencyProperty  ?
                    $@"self.SetValue({DependencyPropertyName}, {camelCaseName});" :
                    $"{accessedWith}.{propertyName} = {camelCaseName};";
            }
        }

        bool ExistInBaseClasses(string propertyName, bool getterAndSetter)
        {
            var existInBaseClasses = false;
            Helpers.LoopDownToObject(mainSymbol.BaseType, type =>
            {
                existInBaseClasses = (type
                    .GetMembers()
                    .FirstOrDefault(e =>
                        e.Kind == SymbolKind.Property &&
                        e.DeclaredAccessibility == Accessibility.Public &&
                        (((IPropertySymbol)e).SetMethod != null || !getterAndSetter) &&
                        e.Name.Equals(propertyName, StringComparison.Ordinal)) != null);

                return existInBaseClasses;
            });
            return existInBaseClasses;
        }

        // --------------------------------------------------
        // ----- attached from interface fluent methods -----    
        // --------------------------------------------------

        void GenerateAttachedPropertiesExtension()
        {
            if (attachedInterfacesAttribute != null)
            {
                List<INamedTypeSymbol> interfaces = new List<INamedTypeSymbol>();

                if (attachedInterfacesAttribute != null)
                {
                    interfaces.AddRange(attachedInterfacesAttribute.ConstructorArguments[1].Values
                        .Select(e => (INamedTypeSymbol)e.Value)
                        .Where(e => e.GetAttributes().FirstOrDefault(e => e.AttributeClass.Name.Equals(Shared.AttachedPropertiesAttributeString)) != null)
                        .ToList());
                }

                interfaces.AddRange(
                    mainSymbol
                        .Interfaces
                        .Where(e => e.GetAttributes().FirstOrDefault(e => e.AttributeClass.Name.Equals(Shared.AttachedPropertiesAttributeString)) != null));

                foreach (var inter in interfaces)
                {
                    var attribute = inter.GetAttributes().FirstOrDefault(e => e.AttributeClass.Name.Equals(Shared.AttachedPropertiesAttributeString));
                    if (attribute != null)
                    {
                        var attachedType = attribute.ConstructorArguments[0].Value as INamedTypeSymbol;

                        if (!attachedType.ToDisplayString().Equals(mainSymbol.ToDisplayString()))
                        {
                            var properties = inter
                                .GetMembers()
                                .Where(e => e.Kind == SymbolKind.Property);

                            foreach (var prop in properties)
                            {
                                var propertySymbol = (IPropertySymbol)prop;
                                var attachedName = Shared.GetAttachedPropertyName(propertySymbol);
                                var fullPropertyName = $"{attachedType.ToDisplayString()}.{attachedName}";
                                GenerateExtensionMethodForDependencyFromInterface(propertySymbol, fullPropertyName);
                            }
                        }
                    }
                }
            }
        }

        // --------------------------------------------------
        // ----- dependency from interface fluent methods -----    
        // --------------------------------------------------

        void GenerateDependencyPropertyExtensionsFromInterface()
        {
            // generate using dependency interface
            var interfaces = mainSymbol
                .Interfaces
                .Where(e => e.GetAttributes().FirstOrDefault(e => e.AttributeClass.Name.Equals(Shared.DependencyPropertiesAttributeString, StringComparison.Ordinal)) != null);

            foreach (var inter in interfaces)
            {
                var properties = inter
                    .GetMembers()
                    .Where(e => e.Kind == SymbolKind.Property);

                foreach (var prop in properties)
                {
                    var propertySymbol = (IPropertySymbol)prop;
                    var fullPropertyName = $"{mainSymbol.ToDisplayString()}.{prop.Name}";
                    GenerateExtensionMethodForDependencyFromInterface(propertySymbol);
                }
            }
        }

        // -------------------------------------------------------
        // ----- dependency properties from interface (both) -----    
        // -------------------------------------------------------

        void GenerateExtensionMethodForDependencyFromInterface(IPropertySymbol propertySymbol, string dependencyPropertyName = null)
        {
            var info = new PropertyInfo
            {
                MainSymbol = mainSymbol,
                DependencyPropertyName = dependencyPropertyName,
                PropertySymbol = propertySymbol,
                IsDependencyProperty = true,
                IsDependencyObject = true
            };
            info.Build();

            if (!Shared.NotGenerateList.Contains(info.propertyName))
            {
                GenerateExtensionMethod_Value(info);
                GenerateExtensionMethod_DependencyPropertyBuilder(info);
                GenerateExtensionMethod_Setters(info);

                if (attachedInterfacesAttribute != null)
                    GenerateExtensionMethod_GetValue(info);
            }
        }

        // -----------------------------------
        // ----- property fluent methods -----    
        // -----------------------------------

        void GenerateExtensionMethod(IPropertySymbol property)
        {
            var info = new PropertyInfo
            {
                MainSymbol = mainSymbol,
                PropertySymbol = property,
                DependencyProperties = dependencyPropertyNames,
                IsDependencyObject = isDependencyObject
            };
            info.Build();

            var propertyType = info.PropertySymbol.Type as INamedTypeSymbol;
            var isGenericIList = Helpers.IsGenericIList(propertyType, out var elementType);

            if (!Shared.NotGenerateList.Contains(info.propertyName))
            {
                if (!isGenericIList &&
                    info.PropertySymbol.SetMethod != null &&
                    info.PropertySymbol.SetMethod.DeclaredAccessibility == Accessibility.Public &&
                    !ExistInBaseClasses(info.propertyName, getterAndSetter: true))
                {
                    GenerateExtensionMethod_Value(info);

                    if (info.IsDependencyProperty)
                    {
                        GenerateExtensionMethod_DependencyPropertyBuilder(info);
                        GenerateExtensionMethod_Setters(info);
                    }
                }
                else if (isGenericIList &&
                    info.PropertySymbol.GetMethod != null &&
                    info.PropertySymbol.GetMethod.DeclaredAccessibility == Accessibility.Public &&
                    !ExistInBaseClasses(info.propertyName, getterAndSetter: false))
                {
                    GenerateExtensionMethod_List(info, elementType.ToDisplayString());
                    if (info.IsDependencyProperty)
                    {
                        GenerateExtensionMethod_DependencyPropertyBuilder(info);
                        GenerateExtensionMethod_Setters(info);
                    }
                }
            }
        }

        void GenerateExtensionMethod_Value(PropertyInfo info)
        {
            if (mainSymbol.IsSealed)
                GenerateExtensionMethod_Value_Sealed(info);
            else
                GenerateExtensionMethod_Value_Normal(info);
        }

        void GenerateExtensionMethod_Value_Sealed(PropertyInfo info)
        {
            isExtensionMethodsGenerated = true;
            builder.Append($@"
        public static {info.symbolTypeName} {info.propertyName}(this {info.symbolTypeName} self,
            {info.propertyTypeName} {info.camelCaseName})
        {{
            {info.valueAssignmentString}
            return self;
        }}
        ");
        }

        void GenerateExtensionMethod_Value_Normal(PropertyInfo info)
        {
            isExtensionMethodsGenerated = true;
            builder.Append($@"
        public static T {info.propertyName}<T>(this T self,
            {info.propertyTypeName} {info.camelCaseName})
            where T : {info.symbolTypeName}
        {{
            {info.valueAssignmentString}
            return self;
        }}
        ");
        }

        void GenerateExtensionMethod_GetValue(PropertyInfo info)
        {
            if (mainSymbol.IsSealed)
                GenerateExtensionMethod_GetValue_Sealed(info);
            else
                GenerateExtensionMethod_GetValue_Normal(info);
        }

        void GenerateExtensionMethod_GetValue_Sealed(PropertyInfo info)
        {
            isExtensionMethodsGenerated = true;
            builder.Append($@"
        public static {info.propertyTypeName} Get{info.propertyName}Value<T>(this {info.symbolTypeName} self)
        {{
            return ({info.propertyTypeName})self.GetValue({info.DependencyPropertyName});
        }}
        ");
        }

        void GenerateExtensionMethod_GetValue_Normal(PropertyInfo info)
        {
            isExtensionMethodsGenerated = true;
            builder.Append($@"
        public static {info.propertyTypeName} Get{info.propertyName}Value<T>(this T self)
            where T : {info.symbolTypeName}
        {{
            return ({info.propertyTypeName})self.GetValue({info.DependencyPropertyName});
        }}
        ");
        }

        // ---- dependency property builder ---

        void GenerateExtensionMethod_DependencyPropertyBuilder(PropertyInfo info)
        {
            if (mainSymbol.IsSealed)
                GenerateExtensionMethod_DependencyPropertyBuilder_Sealed(info);
            else
                GenerateExtensionMethod_DependencyPropertyBuilder_Normal(info);
        }

        void GenerateExtensionMethod_DependencyPropertyBuilder_Sealed(PropertyInfo info)
        {
            isExtensionMethodsGenerated = true;
            builder.Append($@"
        public static {info.symbolTypeName} {info.propertyName}(this {info.symbolTypeName} self, Func<PropertyContext<{info.propertyTypeName}>, IPropertyBuilder<{info.propertyTypeName}>> configure)
        {{
            var context = new PropertyContext<{info.propertyTypeName}>(self, {info.DependencyPropertyName});
            configure(context).Build();
            return self;
        }}
        ");
        }

        void GenerateExtensionMethod_DependencyPropertyBuilder_Normal(PropertyInfo info)
        {
            isExtensionMethodsGenerated = true;
            builder.Append($@"
        public static T {info.propertyName}<T>(this T self, Func<PropertyContext<{info.propertyTypeName}>, IPropertyBuilder<{info.propertyTypeName}>> configure)
            where T : {info.symbolTypeName}
        {{
            var context = new PropertyContext<{info.propertyTypeName}>(self, {info.DependencyPropertyName});
            configure(context).Build();
            return self;
        }}
        ");
        }

        // --- setter property builder ---

        void GenerateExtensionMethod_Setters(PropertyInfo info)
        {
            if (mainSymbol.IsSealed)
                GenerateExtensionMethod_Setters_Sealed(info);
            else
                GenerateExtensionMethod_Setters_Normal(info);
        }

        void GenerateExtensionMethod_Setters_Sealed(PropertyInfo info)
        {
            isExtensionMethodsGenerated = true;
            builder.Append($@"
        public static SettersContext<{info.symbolTypeName}> {info.propertyName}(this SettersContext<{info.symbolTypeName}> self,
            {info.propertyTypeName} {info.camelCaseName})
        {{
            if (self.Target != null)
                self.XamlSetters.Add(new Setter {{ Target = new TargetPropertyPath {{ Path = new PropertyPath(""{info.propertyName}""), Target = self.Target }}, Value = {info.camelCaseName} }});
            else
                self.XamlSetters.Add(new Setter {{ Property = {info.DependencyPropertyName}, Value = {info.camelCaseName} }});
            return self;
        }}
        ");
        }

        void GenerateExtensionMethod_Setters_Normal(PropertyInfo info)
        {
            isExtensionMethodsGenerated = true;
            builder.Append($@"
        public static SettersContext<T> {info.propertyName}<T>(this SettersContext<T> self,
            {info.propertyTypeName} {info.camelCaseName})
            where T : {info.symbolTypeName}
        {{
            if (self.Target != null)
                self.XamlSetters.Add(new Setter {{ Target = new TargetPropertyPath {{ Path = new PropertyPath(""{info.propertyName}""), Target = self.Target }}, Value = {info.camelCaseName} }});
            else
                self.XamlSetters.Add(new Setter {{ Property = {info.DependencyPropertyName}, Value = {info.camelCaseName} }});
            return self;
        }}
        ");
        }

        // -------------------------------
        // ----- list fluent methods -----    
        // -------------------------------

        void GenerateExtensionMethod_List(PropertyInfo info, string elementTypeName)
        {
            if (mainSymbol.IsSealed)
                GenerateExtensionMethod_List_Sealed(info, elementTypeName);
            else
                GenerateExtensionMethod_List_Normal(info, elementTypeName);
        }

        void GenerateExtensionMethod_List_Sealed(PropertyInfo info, string elementTypeName)
        {
            isExtensionMethodsGenerated = true;
            var tail = info.propertyTypeName.EndsWith("?") ? "?" : "";
            builder.Append($@"
        public static {info.symbolTypeName} {info.propertyName}(this {info.symbolTypeName} self,
            IList<{elementTypeName}> {info.camelCaseName})
        {{
            foreach (var item in {info.camelCaseName})
                {info.accessedWith}.{info.propertyName}{tail}.Add(item);
            return self;
        }}

        public static {info.symbolTypeName} {info.propertyName}(this {info.symbolTypeName} self,
            params {elementTypeName}[] {info.camelCaseName})
        {{
            foreach (var item in {info.camelCaseName})
                {info.accessedWith}.{info.propertyName}{tail}.Add(item);
            return self;
        }}
        ");
        }

        void GenerateExtensionMethod_List_Normal(PropertyInfo info, string elementTypeName)
        {
            isExtensionMethodsGenerated = true;
            var tail = info.propertyTypeName.EndsWith("?") ? "?" : "";
            builder.Append($@"
        public static T {info.propertyName}<T>(this T self,
            IList<{elementTypeName}> {info.camelCaseName})
            where T : {info.symbolTypeName}
        {{
            foreach (var item in {info.camelCaseName})
                {info.accessedWith}.{info.propertyName}{tail}.Add(item);
            return self;
        }}

        public static T {info.propertyName}<T>(this T self,
            params {elementTypeName}[] {info.camelCaseName})
            where T : {info.symbolTypeName}
        {{
            foreach (var item in {info.camelCaseName})
                {info.accessedWith}.{info.propertyName}{tail}.Add(item);
            return self;
        }}
        ");
        }

        // --------------------------------
        // ----- event fluent methods -----    
        // --------------------------------

        void GenerateEventMethod(ISymbol @event)
        {
            var eventSymbol = (IEventSymbol)@event;
            var eventHandler = eventSymbol.AddMethod.Parameters.First();
            var eventHandlerType = ((INamedTypeSymbol)eventHandler.Type);

            var existInBases = false;
            Helpers.LoopDownToObject(mainSymbol.BaseType, type =>
            {
                existInBases = (type
                    .GetMembers()
                    .FirstOrDefault(e =>
                        e.Kind == SymbolKind.Event &&
                        e.DeclaredAccessibility == Accessibility.Public &&
                        e.Name.Equals(eventSymbol.Name, StringComparison.Ordinal)) != null);

                return existInBases;
            });

            if (!existInBases && !Shared.NotGenerateList.Contains(eventSymbol.Name))
            {
                if (mainSymbol.IsSealed)
                {
                    GenerateEventMethodHandler_Sealed(eventSymbol, eventHandlerType);
                    GenerateEventMethodNoArgs_Sealed(eventSymbol);
                }
                else
                {
                    GenerateEventMethodHandler_Normal(eventSymbol, eventHandlerType);
                    GenerateEventMethodNoArgs_Normal(eventSymbol);
                }
            }
        }

        void GenerateEventMethodHandler_Sealed(IEventSymbol eventSymbol, INamedTypeSymbol namedType)
        {
            isExtensionMethodsGenerated = true;
            builder.Append($@"
        public static {mainSymbol.ToDisplayString()} On{eventSymbol.Name}(this {mainSymbol.ToDisplayString()} self, {namedType.ToDisplayString()} handler)
        {{
            self.{eventSymbol.Name} += handler;
            return self;
        }}
        ");
        }

        void GenerateEventMethodHandler_Normal(IEventSymbol eventSymbol, INamedTypeSymbol namedType)
        {
            isExtensionMethodsGenerated = true;
            builder.Append($@"
        public static T On{eventSymbol.Name}<T>(this T self, {namedType.ToDisplayString()} handler)
            where T : {mainSymbol.ToDisplayString()}
        {{
            self.{eventSymbol.Name} += handler;
            return self;
        }}
        ");
        }

        void GenerateEventMethodNoArgs_Sealed(IEventSymbol eventSymbol)
        {
            isExtensionMethodsGenerated = true;
            builder.Append($@"
        public static {mainSymbol.ToDisplayString()} On{eventSymbol.Name}(this {mainSymbol.ToDisplayString()} self, System.Action<{mainSymbol.ToDisplayString()}> action)
        {{
            self.{eventSymbol.Name} += (o, arg) => action(self);
            return self;
        }}
        ");
        }

        void GenerateEventMethodNoArgs_Normal(IEventSymbol eventSymbol)
        {
            isExtensionMethodsGenerated = true;
            builder.Append($@"
        public static T On{eventSymbol.Name}<T>(this T self, System.Action<T> action)
            where T : {mainSymbol.ToDisplayString()}
        {{
            self.{eventSymbol.Name} += (o, arg) => action(self);
            return self;
        }}
        ");
        }
    }
}

